---
description: 'Documentation for Arithmetic Functions'
sidebar_label: 'Arithmetic'
slug: /sql-reference/functions/arithmetic-functions
title: 'Arithmetic Functions'
doc_type: 'reference'
---

## Overview [#overview]

Arithmetic functions work for any two operands of type `UInt8`, `UInt16`, `UInt32`, `UInt64`, `Int8`, `Int16`, `Int32`, `Int64`, `Float32`, or `Float64`.

Before performing the operation, both operands are cast to the result type. The result type is determined as follows (unless specified
differently in the function documentation below):
- If both operands are up to 32 bits wide, the size of the result type will be the size of the next bigger type following the bigger of the
  two operands (integer size promotion). For example, `UInt8 + UInt16 = UInt32` or `Float32 * Float32 = Float64`.
- If one of the operands has 64 or more bits, the size of the result type will be the same size as the bigger of the two operands. For
  example, `UInt32 + UInt128 = UInt128` or `Float32 * Float64 = Float64`.
- If one of the operands is signed, the result type will also be signed, otherwise it will be signed. For example, `UInt32 * Int32 = Int64`.

These rules make sure that the result type will be the smallest type which can represent all possible results. While this introduces a risk
of overflows around the value range boundary, it ensures that calculations are performed quickly using the maximum native integer width of
64 bit. This behavior also guarantees compatibility with many other databases which provide 64 bit integers (BIGINT) as the biggest integer
type.

Example:

```sql
SELECT toTypeName(0), toTypeName(0 + 0), toTypeName(0 + 0 + 0), toTypeName(0 + 0 + 0 + 0)
```

```text
┌─toTypeName(0)─┬─toTypeName(plus(0, 0))─┬─toTypeName(plus(plus(0, 0), 0))─┬─toTypeName(plus(plus(plus(0, 0), 0), 0))─┐
│ UInt8         │ UInt16                 │ UInt32                          │ UInt64                                   │
└───────────────┴────────────────────────┴─────────────────────────────────┴──────────────────────────────────────────┘
```

Overflows are produced the same way as in C++.

{/* <!-- 
The inner content of the tags below are replaced at doc framework build time with 
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
--> */}

{/* <!--AUTOGENERATED_START--> */}
## abs <Badge intent="info" className="version-badge">v1.1+</Badge> [#abs]

Calculates the absolute value of `x`. Has no effect if `x` is of an unsigned type. If `x` is of a signed type, it returns an unsigned number.

**Syntax**

```sql
abs(x)
```

**Arguments**

- `x` — Value to get the absolute value of 

**Returned value**

The absolute value of `x`

**Examples**

**Usage example**

```sql title=Query
SELECT abs(-0.5)
```

```response title=Response
0.5
```



## avg2 <Badge intent="info" className="version-badge">v25.11+</Badge> [#avg2]


Computes and returns the average value of the provided arguments.
Supports numerical and temporal types.
    

**Syntax**

```sql
avg2(x1, x2])
```

**Arguments**

- `x1, x2]` — Accepts two values for averaging. 

**Returned value**

Returns the average value of the provided arguments, promoted to the largest compatible type.

**Examples**

**Numeric types**

```sql title=Query
SELECT avg2(toUInt8(3), 1.0) AS result, toTypeName(result) AS type;
-- The type returned is a Float64 as the UInt8 must be promoted to 64 bit for the comparison.
```

```response title=Response
┌─result─┬─type────┐
│      2 │ Float64 │
└────────┴─────────┘
```

**Decimal types**

```sql title=Query
SELECT avg2(toDecimal32(1, 2), 2) AS result, toTypeName(result) AS type;
```

```response title=Response
┌─result─┬─type──────────┐
│    1.5 │ Decimal(9, 2) │
└────────┴───────────────┘
```

**Date types**

```sql title=Query
SELECT avg2(toDate('2025-01-01'), toDate('2025-01-05')) AS result, toTypeName(result) AS type;
```

```response title=Response
┌─────result─┬─type─┐
│ 2025-01-03 │ Date │
└────────────┴──────┘
```

**DateTime types**

```sql title=Query
SELECT avg2(toDateTime('2025-01-01 00:00:00'), toDateTime('2025-01-03 12:00:00')) AS result, toTypeName(result) AS type;
```

```response title=Response
┌──────────────result─┬─type─────┐
│ 2025-01-02 06:00:00 │ DateTime │
└─────────────────────┴──────────┘
```

**Time64 types**

```sql title=Query
SELECT avg2(toTime64('12:00:00', 0), toTime64('14:00:00', 0)) AS result, toTypeName(result) AS type;
```

```response title=Response
┌───result─┬─type──────┐
│ 13:00:00 │ Time64(0) │
└──────────┴───────────┘
```



## byteSwap <Badge intent="info" className="version-badge">v23.10+</Badge> [#byteSwap]


Reverses the bytes of an integer, i.e. changes its [endianness](https://en.wikipedia.org/wiki/Endianness).

The below example can be worked out in the following manner:

1. Convert the base-10 integer to its equivalent hexadecimal format in big-endian format, i.e. 3351772109 -> C7 C7 FB CD (4 bytes)
2. Reverse the bytes, i.e. C7 C7 FB CD -> CD FB C7 C7
3. Convert the result back to an integer assuming big-endian, i.e. CD FB C7 C7 -> 3455829959
One use case of this function is reversing IPv4s:

```result
┌─toIPv4(byteSwap(toUInt32(toIPv4('205.251.199.199'))))─┐
│ 199.199.251.205                                       │
└───────────────────────────────────────────────────────┘
```
    

**Syntax**

```sql
byteSwap(x)
```

**Arguments**

- `x` — An integer value. [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns `x` with bytes reversed. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT byteSwap(3351772109)
```

```response title=Response
3455829959
```

**8-bit**

```sql title=Query
SELECT byteSwap(54)
```

```response title=Response
54
```

**16-bit**

```sql title=Query
SELECT byteSwap(4135)
```

```response title=Response
10000
```

**32-bit**

```sql title=Query
SELECT byteSwap(3351772109)
```

```response title=Response
3455829959
```

**64-bit**

```sql title=Query
SELECT byteSwap(123294967295)
```

```response title=Response
18439412204227788800
```



## divide <Badge intent="info" className="version-badge">v1.1+</Badge> [#divide]


Calculates the quotient of two values `a` and `b`. The result type is always [Float64](/sql-reference/data-types/float).
Integer division is provided by the `intDiv` function.

<Note>
Division by `0` returns `inf`, `-inf`, or `nan`.
</Note>
    

**Syntax**

```sql
divide(x, y)
```

**Arguments**

- `x` — Dividend - `y` — Divisor 

**Returned value**

The quotient of x and y

**Examples**

**Dividing two numbers**

```sql title=Query
SELECT divide(25,5) AS quotient, toTypeName(quotient)
```

```response title=Response
5 Float64
```

**Dividing by zero**

```sql title=Query
SELECT divide(25,0)
```

```response title=Response
inf
```



## divideDecimal <Badge intent="info" className="version-badge">v22.12+</Badge> [#divideDecimal]


Performs division on two decimals. Result value will be of type [Decimal256](/sql-reference/data-types/decimal).
Result scale can be explicitly specified by `result_scale` argument (const Integer in range `[0, 76]`). If not specified, the result scale is the max scale of given arguments.

<Note>
These function work significantly slower than usual `divide`.
In case you don't really need controlled precision and/or need fast computation, consider using [divide](#divide).
</Note>
    

**Syntax**

```sql
divideDecimal(x, y[, result_scale])
```

**Arguments**

- `x` — First value: [Decimal](/sql-reference/data-types/decimal). - `y` — Second value: [Decimal](/sql-reference/data-types/decimal). - `result_scale` — Scale of result. Type [Int/UInt](/sql-reference/data-types/int-uint). 

**Returned value**

The result of division with given scale. [`Decimal256`](/sql-reference/data-types/decimal)

**Examples**

**Example 1**

```sql title=Query
divideDecimal(toDecimal256(-12, 0), toDecimal32(2.1, 1), 10)
```

```response title=Response
┌─divideDecimal(toDecimal256(-12, 0), toDecimal32(2.1, 1), 10)─┐
│                                                -5.7142857142 │
└──────────────────────────────────────────────────────────────┘
```

**Example 2**

```sql title=Query
SELECT toDecimal64(-12, 1) / toDecimal32(2.1, 1);
SELECT toDecimal64(-12, 1) as a, toDecimal32(2.1, 1) as b, divideDecimal(a, b, 1), divideDecimal(a, b, 5);
```

```response title=Response
┌─divide(toDecimal64(-12, 1), toDecimal32(2.1, 1))─┐
│                                             -5.7 │
└──────────────────────────────────────────────────┘
┌───a─┬───b─┬─divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 1)─┬─divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 5)─┐
│ -12 │ 2.1 │                                                       -5.7 │                                                   -5.71428 │
└─────┴─────┴────────────────────────────────────────────────────────────┴────────────────────────────────────────────────────────────┘
```



## divideOrNull <Badge intent="info" className="version-badge">v25.5+</Badge> [#divideOrNull]


Same as `divide` but returns NULL when dividing by zero.
    

**Syntax**

```sql
divideOrNull(x, y)
```

**Arguments**

- `x` — Dividend - `y` — Divisor 

**Returned value**

The quotient of x and y, or NULL.

**Examples**

**Dividing by zero**

```sql title=Query
SELECT divideOrNull(25, 0)
```

```response title=Response
\N
```



## gcd <Badge intent="info" className="version-badge">v1.1+</Badge> [#gcd]


    Returns the greatest common divisor of two values a and b.

    An exception is thrown when dividing by zero or when dividing a minimal
    negative number by minus one.
    

**Syntax**

```sql
gcd(x, y)
```

**Arguments**

- `x` — First integer - `y` — Second integer 

**Returned value**

The greatest common divisor of `x` and `y`.

**Examples**

**Usage example**

```sql title=Query
SELECT gcd(12, 18)
```

```response title=Response
6
```



## ifNotFinite <Badge intent="info" className="version-badge">v20.3+</Badge> [#ifNotFinite]


Checks whether a floating point value is finite.

You can get a similar result by using the [ternary operator](/sql-reference/functions/conditional-functions#if): `isFinite(x) ? x : y`.
    

**Syntax**

```sql
ifNotFinite(x,y)
```

**Arguments**

- `x` — Value to check if infinite. [`Float*`](/sql-reference/data-types/float)
- `y` — Fallback value. [`Float*`](/sql-reference/data-types/float)


**Returned value**

- `x` if `x` is finite.
- `y` if `x` is not finite.

**Examples**

**Usage example**

```sql title=Query
SELECT 1/0 AS infimum, ifNotFinite(infimum,42)
```

```response title=Response
inf  42
```



## intDiv <Badge intent="info" className="version-badge">v1.1+</Badge> [#intDiv]


Performs an integer division of two values `x` by `y`. In other words it
computes the quotient rounded down to the next smallest integer.

The result has the same width as the dividend (the first parameter).

An exception is thrown when dividing by zero, when the quotient does not fit
in the range of the dividend, or when dividing a minimal negative number by minus one.
    

**Syntax**

```sql
intDiv(x, y)
```

**Arguments**

- `x` — Left hand operand. - `y` — Right hand operand. 

**Returned value**

Result of integer division of `x` and `y`

**Examples**

**Integer division of two floats**

```sql title=Query
SELECT intDiv(toFloat64(1), 0.001) AS res, toTypeName(res)
```

```response title=Response
┌──res─┬─toTypeName(intDiv(toFloat64(1), 0.001))─┐
│ 1000 │ Int64                                   │
└──────┴─────────────────────────────────────────┘
```

**Quotient does not fit in the range of the dividend**

```sql title=Query
SELECT
intDiv(1, 0.001) AS res,
toTypeName(res)
```

```response title=Response
Received exception from server (version 23.2.1):
Code: 153. DB::Exception: Received from localhost:9000. DB::Exception:
Cannot perform integer division, because it will produce infinite or too
large number: While processing intDiv(1, 0.001) AS res, toTypeName(res).
(ILLEGAL_DIVISION)
```



## intDivOrNull <Badge intent="info" className="version-badge">v25.5+</Badge> [#intDivOrNull]


Same as `intDiv` but returns NULL when dividing by zero or when dividing a
minimal negative number by minus one.
    

**Syntax**

```sql
intDivOrNull(x, y)
```

**Arguments**

- `x` — Left hand operand. [`(U)Int*`](/sql-reference/data-types/int-uint)
- `y` — Right hand operand. [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Result of integer division of `x` and `y`, or NULL.

**Examples**

**Integer division by zero**

```sql title=Query
SELECT intDivOrNull(1, 0)
```

```response title=Response
\N
```

**Dividing a minimal negative number by minus 1**

```sql title=Query
SELECT intDivOrNull(-9223372036854775808, -1)
```

```response title=Response
\N
```



## intDivOrZero <Badge intent="info" className="version-badge">v1.1+</Badge> [#intDivOrZero]


Same as `intDiv` but returns zero when dividing by zero or when dividing a
minimal negative number by minus one.
    

**Syntax**

```sql
intDivOrZero(a, b)
```

**Arguments**

- `a` — Left hand operand. [`(U)Int*`](/sql-reference/data-types/int-uint)
- `b` — Right hand operand. [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Result of integer division of a and b, or zero.

**Examples**

**Integer division by zero**

```sql title=Query
SELECT intDivOrZero(1, 0)
```

```response title=Response
0
```

**Dividing a minimal negative number by minus 1**

```sql title=Query
SELECT intDivOrZero(0.05, -1)
```

```response title=Response
0
```



## isFinite <Badge intent="info" className="version-badge">v1.1+</Badge> [#isFinite]


Returns `1` if the Float32 or Float64 argument not infinite and not a `NaN`,
otherwise this function returns `0`.
    

**Syntax**

```sql
isFinite(x)
```

**Arguments**

- `x` — Number to check for finiteness. [`Float*`](/sql-reference/data-types/float)


**Returned value**

`1` if x is not infinite and not `NaN`, otherwise `0`.

**Examples**

**Test if a number is finite**

```sql title=Query
SELECT isFinite(inf)
```

```response title=Response
0
```



## isInfinite <Badge intent="info" className="version-badge">v1.1+</Badge> [#isInfinite]


    Returns `1` if the Float32 or Float64 argument is infinite, otherwise this function returns `0`.
    Note that `0` is returned for a `NaN`.
    

**Syntax**

```sql
isInfinite(x)
```

**Arguments**

- `x` — Number to check for infiniteness. [`Float*`](/sql-reference/data-types/float)


**Returned value**

`1` if x is infinite, otherwise `0` (including for `NaN`).

**Examples**

**Test if a number is infinite**

```sql title=Query
SELECT isInfinite(inf), isInfinite(NaN), isInfinite(10))
```

```response title=Response
1 0 0
```



## isNaN <Badge intent="info" className="version-badge">v1.1+</Badge> [#isNaN]

Returns `1` if the Float32 and Float64 argument is `NaN`, otherwise returns `0`.

**Syntax**

```sql
isNaN(x)
```

**Arguments**

- `x` — Argument to evaluate for if it is `NaN`. [`Float*`](/sql-reference/data-types/float)


**Returned value**

`1` if `NaN`, otherwise `0`

**Examples**

**Usage example**

```sql title=Query
SELECT isNaN(NaN)
```

```response title=Response
1
```



## lcm <Badge intent="info" className="version-badge">v1.1+</Badge> [#lcm]


Returns the least common multiple of two values `x` and `y`.

An exception is thrown when dividing by zero or when dividing a minimal negative number by minus one.
    

**Syntax**

```sql
lcm(x, y)
```

**Arguments**

- `x` — First integer. [`(U)Int*`](/sql-reference/data-types/int-uint)
- `y` — Second integer. [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns the least common multiple of `x` and `y`. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT lcm(6, 8)
```

```response title=Response
24
```



## max2 <Badge intent="info" className="version-badge">v21.11+</Badge> [#max2]


    Returns the bigger of two numeric values `x` and `y`.
    

**Syntax**

```sql
max2(x, y)
```

**Arguments**

- `x` — First value [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal)
- `y` — Second value [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal)


**Returned value**

Returns the bigger value of `x` and `y`. [`Float64`](/sql-reference/data-types/float)

**Examples**

**Usage example**

```sql title=Query
SELECT max2(-1, 2)
```

```response title=Response
2
```



## midpoint <Badge intent="info" className="version-badge">v25.11+</Badge> [#midpoint]


Computes and returns the average value of the provided arguments.
Supports numerical and temporal types.
    

**Syntax**

```sql
midpoint(x1[, x2, ...])
```

**Arguments**

- `x1[, x2, ...]` — Accepts a single value or multiple values for averaging. 

**Returned value**

Returns the average value of the provided arguments, promoted to the largest compatible type.

**Examples**

**Numeric types**

```sql title=Query
SELECT midpoint(1, toUInt8(3), 0.5) AS result, toTypeName(result) AS type;
-- The type returned is a Float64 as the UInt8 must be promoted to 64 bit for the comparison.
```

```response title=Response
┌─result─┬─type────┐
│    1.5 │ Float64 │
└────────┴─────────┘
```

**Decimal types**

```sql title=Query
SELECT midpoint(toDecimal32(1.5, 2), toDecimal32(1, 1), 2) AS result, toTypeName(result) AS type;
```

```response title=Response
┌─result─┬─type──────────┐
│    1.5 │ Decimal(9, 2) │
└────────┴───────────────┘
```

**Date types**

```sql title=Query
SELECT midpoint(toDate('2025-01-01'), toDate('2025-01-05')) AS result, toTypeName(result) AS type;
```

```response title=Response
┌─────result─┬─type─┐
│ 2025-01-03 │ Date │
└────────────┴──────┘
```

**DateTime types**

```sql title=Query
SELECT midpoint(toDateTime('2025-01-01 00:00:00'), toDateTime('2025-01-03 12:00:00')) AS result, toTypeName(result) AS type;
```

```response title=Response
┌──────────────result─┬─type─────┐
│ 2025-01-02 06:00:00 │ DateTime │
└─────────────────────┴──────────┘
```

**Time64 types**

```sql title=Query
SELECT midpoint(toTime64('12:00:00', 0), toTime64('14:00:00', 0)) AS result, toTypeName(result) AS type;
```

```response title=Response
┌───result─┬─type──────┐
│ 13:00:00 │ Time64(0) │
└──────────┴───────────┘
```



## min2 <Badge intent="info" className="version-badge">v21.11+</Badge> [#min2]


    Returns the smaller of two numeric values `x` and `y`.
    

**Syntax**

```sql
min2(x, y)
```

**Arguments**

- `x` — First value [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal)
- `y` — Second value [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal)


**Returned value**

Returns the smaller value of `x` and `y`. [`Float64`](/sql-reference/data-types/float)

**Examples**

**Usage example**

```sql title=Query
SELECT min2(-1, 2)
```

```response title=Response
-1
```



## minus <Badge intent="info" className="version-badge">v1.1+</Badge> [#minus]


Calculates the difference of two values `a` and `b`. The result is always signed.
Similar to plus, it is possible to subtract an integer from a date or date with time.
Additionally, subtraction between date with time is supported, resulting in the time difference between them.
    

**Syntax**

```sql
minus(x, y)
```

**Arguments**

- `x` — Minuend. - `y` — Subtrahend. 

**Returned value**

x minus y

**Examples**

**Subtracting two numbers**

```sql title=Query
SELECT minus(10, 5)
```

```response title=Response
5
```

**Subtracting an integer and a date**

```sql title=Query
SELECT minus(toDate('2025-01-01'),5)
```

```response title=Response
2024-12-27
```



## modulo <Badge intent="info" className="version-badge">v1.1+</Badge> [#modulo]


    Calculates the remainder of the division of two values a by b.

    The result type is an integer if both inputs are integers. If one of the
    inputs is a floating-point number, the result type is Float64.

    The remainder is computed like in C++. Truncated division is used for
    negative numbers.

    An exception is thrown when dividing by zero or when dividing a minimal
    negative number by minus one.
    

**Syntax**

```sql
modulo(a, b)
```

**Aliases**: `mod`

**Arguments**

- `a` — The dividend - `b` — The divisor (modulus) 

**Returned value**

The remainder of a % b

**Examples**

**Usage example**

```sql title=Query
SELECT modulo(5, 2)
```

```response title=Response
1
```



## moduloOrNull <Badge intent="info" className="version-badge">v25.5+</Badge> [#moduloOrNull]


Calculates the remainder when dividing `a` by `b`. Similar to function `modulo` except that `moduloOrNull` will return NULL
if the right argument is 0.
    

**Syntax**

```sql
moduloOrNull(x, y)
```

**Aliases**: `modOrNull`

**Arguments**

- `x` — The dividend. [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float)
- `y` — The divisor (modulus). [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float)


**Returned value**

Returns the remainder of the division of `x` by `y`, or null when the divisor is zero.

**Examples**

**moduloOrNull by zero**

```sql title=Query
SELECT moduloOrNull(5, 0)
```

```response title=Response
\N
```



## moduloOrZero <Badge intent="info" className="version-badge">v20.3+</Badge> [#moduloOrZero]


Like modulo but returns zero when the divisor is zero, as opposed to an
exception with the modulo function.
    

**Syntax**

```sql
moduloOrZero(a, b)
```

**Arguments**

- `a` — The dividend. [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float)
- `b` — The divisor (modulus). [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float)


**Returned value**

Returns the remainder of a % b, or `0` when the divisor is `0`.

**Examples**

**Usage example**

```sql title=Query
SELECT moduloOrZero(5, 0)
```

```response title=Response
0
```



## multiply <Badge intent="info" className="version-badge">v1.1+</Badge> [#multiply]

Calculates the product of two values `x` and `y`.

**Syntax**

```sql
multiply(x, y)
```

**Arguments**

- `x` — factor. [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal)
- `y` — factor. [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal)


**Returned value**

Returns the product of x and y

**Examples**

**Multiplying two numbers**

```sql title=Query
SELECT multiply(5,5)
```

```response title=Response
25
```



## multiplyDecimal <Badge intent="info" className="version-badge">v22.12+</Badge> [#multiplyDecimal]


Performs multiplication on two decimals. Result value will be of type [Decimal256](/sql-reference/data-types/decimal).
Result scale can be explicitly specified by `result_scale` argument (const Integer in range `[0, 76]`). If not specified, the result scale is the max scale of given arguments.

<Note>
These functions work significantly slower than usual `multiply`.
In case you don't really need controlled precision and/or need fast computation, consider using [multiply](#multiply)
</Note>
    

**Syntax**

```sql
multiplyDecimal(a, b[, result_scale])
```

**Arguments**

- `a` — First value. [`Decimal`](/sql-reference/data-types/decimal)
- `b` — Second value. [`Decimal`](/sql-reference/data-types/decimal)
- `result_scale` — Scale of result. [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

The result of multiplication with the given scale. Type: [`Decimal256`](/sql-reference/data-types/decimal)

**Examples**

**Usage example**

```sql title=Query
SELECT multiplyDecimal(toDecimal256(-12, 0), toDecimal32(-2.1, 1), 1)
```

```response title=Response
25.2
```

**Difference with regular multiplication**

```sql title=Query
SELECT multiplyDecimal(toDecimal256(-12, 0), toDecimal32(-2.1, 1), 1)
```

```response title=Response
┌─multiply(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))─┐
│                                               -26.8609633 │
└───────────────────────────────────────────────────────────┘
┌─multiplyDecimal(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))─┐
│                                                         -26.8609 │
└──────────────────────────────────────────────────────────────────┘
```

**Decimal overflow**

```sql title=Query
SELECT
    toDecimal64(-12.647987876, 9) AS a,
    toDecimal64(123.967645643, 9) AS b,
    multiplyDecimal(a, b);
SELECT
    toDecimal64(-12.647987876, 9) AS a,
    toDecimal64(123.967645643, 9) AS b,
    a * b;
```

```response title=Response
┌─────────────a─┬─────────────b─┬─multiplyDecimal(toDecimal64(-12.647987876, 9), toDecimal64(123.967645643, 9))─┐
│ -12.647987876 │ 123.967645643 │                                                               -1567.941279108 │
└───────────────┴───────────────┴───────────────────────────────────────────────────────────────────────────────┘
Received exception from server (version 22.11.1):
Code: 407. DB::Exception: Received from localhost:9000. DB::Exception: Decimal math overflow:
While processing toDecimal64(-12.647987876, 9) AS a, toDecimal64(123.967645643, 9) AS b, a * b. (DECIMAL_OVERFLOW)
```



## negate <Badge intent="info" className="version-badge">v1.1+</Badge> [#negate]

Negates the argument `x`. The result is always signed.

**Syntax**

```sql
negate(x)
```

**Arguments**

- `x` — The value to negate. 

**Returned value**

Returns -x from x

**Examples**

**Usage example**

```sql title=Query
SELECT negate(10)
```

```response title=Response
-10
```



## plus <Badge intent="info" className="version-badge">v1.1+</Badge> [#plus]


Calculates the sum of two values `x` and `y`. Alias: `x + y` (operator).
It is possible to add an integer and a date or date with time. The former
operation increments the number of days in the date, the latter operation
increments the number of seconds in the date with time.
    

**Syntax**

```sql
plus(x, y)
```

**Arguments**

- `x` — Left hand operand. - `y` — Right hand operand. 

**Returned value**

Returns the sum of x and y

**Examples**

**Adding two numbers**

```sql title=Query
SELECT plus(5,5)
```

```response title=Response
10
```

**Adding an integer and a date**

```sql title=Query
SELECT plus(toDate('2025-01-01'),5)
```

```response title=Response
2025-01-06
```



## positiveModulo <Badge intent="info" className="version-badge">v22.11+</Badge> [#positiveModulo]


Calculates the remainder when dividing `x` by `y`. Similar to function
`modulo` except that `positiveModulo` always return non-negative number.
    

**Syntax**

```sql
positiveModulo(x, y)
```

**Aliases**: `positive_modulo`, `pmod`

**Arguments**

- `x` — The dividend. [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal)
- `y` — The divisor (modulus). [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal)


**Returned value**

Returns the difference between `x` and the nearest integer not greater than
`x` divisible by `y`.

**Examples**

**Usage example**

```sql title=Query
SELECT positiveModulo(-1, 10)
```

```response title=Response
9
```



## positiveModuloOrNull <Badge intent="info" className="version-badge">v25.5+</Badge> [#positiveModuloOrNull]


Calculates the remainder when dividing `a` by `b`. Similar to function `positiveModulo` except that `positiveModuloOrNull` will return NULL
if the right argument is 0.
    

**Syntax**

```sql
positiveModuloOrNull(x, y)
```

**Aliases**: `positive_modulo_or_null`, `pmodOrNull`

**Arguments**

- `x` — The dividend. [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float). - `x` — The divisor (modulus). [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float). 

**Returned value**

Returns the difference between `x` and the nearest integer not greater than
`x` divisible by `y`, `null` when the divisor is zero.

**Examples**

**positiveModuloOrNull**

```sql title=Query
SELECT positiveModuloOrNull(5, 0)
```

```response title=Response
\N
```



{/* <!--AUTOGENERATED_END--> */}
