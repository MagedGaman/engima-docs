---
description: 'Documentation for Json Functions'
sidebar_label: 'JSON'
slug: /sql-reference/functions/json-functions
title: 'JSON Functions'
doc_type: 'reference'
---

## Types of JSON functions [#types-of-functions]

There are two sets of functions to parse JSON:
- [`simpleJSON*` (`visitParam*`)](#simplejson-visitparam-functions) which is made for parsing a limited subset of JSON extremely fast.
- [`JSONExtract*`](#jsonextract-functions) which is made for parsing ordinary JSON.

### simpleJSON (visitParam) functions [#simplejson-visitparam-functions]

ClickHouse has special functions for working with simplified JSON. All these JSON functions are based on strong assumptions about what the JSON can be. They try to do as little as possible to get the job done as quickly as possible.

The following assumptions are made:

1.  The field name (function argument) must be a constant.
2.  The field name is somehow canonically encoded in JSON. For example: `simpleJSONHas('{"abc":"def"}', 'abc') = 1`, but `simpleJSONHas('{"\\u0061\\u0062\\u0063":"def"}', 'abc') = 0`
3.  Fields are searched for on any nesting level, indiscriminately. If there are multiple matching fields, the first occurrence is used.
4.  The JSON does not have space characters outside of string literals.

### JSONExtract functions [#jsonextract-functions]

These functions are based on [simdjson](https://github.com/lemire/simdjson), and designed for more complex JSON parsing requirements.

### Case-Insensitive JSONExtract Functions [#case-insensitive-jsonextract-functions]

These functions perform ASCII case-insensitive key matching when extracting values from JSON objects.
They work identically to their case-sensitive counterparts, except that object keys are matched without regard to case.
When multiple keys match with different cases, the first match is returned.

<Note>
These functions may be less performant than their case-sensitive counterparts, so use the regular JSONExtract functions if possible.
</Note>

{/* <!-- 
The inner content of the tags below are replaced at doc framework build time with 
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
--> */}

{/* <!--AUTOGENERATED_START--> */}
## JSONAllPaths <Badge intent="info" className="version-badge">v24.8+</Badge> [#JSONAllPaths]


Returns the list of all paths stored in each row in JSON column.
        

**Syntax**

```sql
JSONAllPaths(json)
```

**Arguments**

- `json` — JSON column. [`JSON`](/sql-reference/data-types/newjson)


**Returned value**

Returns an array of all paths in the JSON column. [`Array(String)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONAllPaths(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONAllPaths(json)─┐
│ {"a":"42"}                           │ ['a']              │
│ {"b":"Hello"}                        │ ['b']              │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ ['a','c']          │
└──────────────────────────────────────┴────────────────────┘
```



## JSONAllPathsWithTypes <Badge intent="info" className="version-badge">v24.8+</Badge> [#JSONAllPathsWithTypes]


Returns the list of all paths and their data types stored in each row in JSON column.
        

**Syntax**

```sql
JSONAllPathsWithTypes(json)
```

**Arguments**

- `json` — JSON column. [`JSON`](/sql-reference/data-types/newjson)


**Returned value**

Returns a map of all paths and their data types in the JSON column. [`Map(String, String)`](/sql-reference/data-types/map)

**Examples**

**Usage example**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONAllPathsWithTypes(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONAllPathsWithTypes(json)───────────────┐
│ {"a":"42"}                           │ {'a':'Int64'}                             │
│ {"b":"Hello"}                        │ {'b':'String'}                            │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ {'a':'Array(Nullable(Int64))','c':'Date'} │
└──────────────────────────────────────┴───────────────────────────────────────────┘
```



## JSONArrayLength <Badge intent="info" className="version-badge">v23.2+</Badge> [#JSONArrayLength]


Returns the number of elements in the outermost JSON array.
The function returns `NULL` if input JSON string is invalid.
    

**Syntax**

```sql
JSONArrayLength(json)
```

**Aliases**: `JSON_ARRAY_LENGTH`

**Arguments**

- `json` — String with valid JSON. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns the number of array elements if `json` is a valid JSON array string, otherwise returns `NULL`. [`Nullable(UInt64)`](/sql-reference/data-types/nullable)

**Examples**

**Usage example**

```sql title=Query
SELECT
    JSONArrayLength(''),
    JSONArrayLength('[1,2,3]');
```

```response title=Response
┌─JSONArrayLength('')─┬─JSONArrayLength('[1,2,3]')─┐
│                ᴺᵁᴸᴸ │                          3 │
└─────────────────────┴────────────────────────────┘
```



## JSONDynamicPaths <Badge intent="info" className="version-badge">v24.8+</Badge> [#JSONDynamicPaths]


Returns the list of dynamic paths that are stored as separate subcolumns in JSON column.
        

**Syntax**

```sql
JSONDynamicPaths(json)
```

**Arguments**

- `json` — JSON column. [`JSON`](/sql-reference/data-types/newjson)


**Returned value**

Returns an array of dynamic paths in the JSON column. [`Array(String)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONDynamicPaths(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONDynamicPaths(json)─┐
│ {"a":"42"}                           │ ['a']                  │
│ {"b":"Hello"}                        │ []                     │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ ['a']                  │
└──────────────────────────────────────┴────────────────────────┘
```



## JSONDynamicPathsWithTypes <Badge intent="info" className="version-badge">v24.8+</Badge> [#JSONDynamicPathsWithTypes]


Returns the list of dynamic paths that are stored as separate subcolumns and their types in each row in JSON column.
        

**Syntax**

```sql
JSONDynamicPathsWithTypes(json)
```

**Arguments**

- `json` — JSON column. [`JSON`](/sql-reference/data-types/newjson)


**Returned value**

Returns a map of dynamic paths and their data types in the JSON column. [`Map(String, String)`](/sql-reference/data-types/map)

**Examples**

**Usage example**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONDynamicPathsWithTypes(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONDynamicPathsWithTypes(json)─┐
│ {"a":"42"}                           │ {'a':'Int64'}                   │
│ {"b":"Hello"}                        │ {}                              │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ {'a':'Array(Nullable(Int64))'}  │
└──────────────────────────────────────┴─────────────────────────────────┘
```



## JSONExtract <Badge intent="info" className="version-badge">v19.14+</Badge> [#JSONExtract]


Parses JSON and extracts a value with given ClickHouse data type.
        

**Syntax**

```sql
JSONExtract(json[, indices_or_keys, ...], return_type)
```

**Arguments**

- `json` — JSON string to parse. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — A list of zero or more arguments each of which can be either string or integer. [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)
- `return_type` — ClickHouse data type to return. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns a value of specified ClickHouse data type if possible, otherwise returns the default value for that type.

**Examples**

**Usage example**

```sql title=Query
SELECT JSONExtract('{"a": "hello", "b": [-100, 200.0, 300]}', 'Tuple(String, Array(Float64))') AS res;
```

```response title=Response
┌─res──────────────────────────────┐
│ ('hello',[-100,200,300])         │
└──────────────────────────────────┘
```



## JSONExtractArrayRaw <Badge intent="info" className="version-badge">v20.1+</Badge> [#JSONExtractArrayRaw]


Returns an array with elements of JSON array, each represented as unparsed string.
        

**Syntax**

```sql
JSONExtractArrayRaw(json[, indices_or_keys, ...])
```

**Arguments**

- `json` — JSON string to parse. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — A list of zero or more arguments each of which can be either string or integer. [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns an array of strings with JSON array elements. If the part is not an array or does not exist, an empty array will be returned. [`Array(String)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT JSONExtractArrayRaw('{"a": "hello", "b": [-100, 200.0, "hello"]}', 'b') AS res;
```

```response title=Response
┌─res──────────────────────────┐
│ ['-100','200.0','"hello"']   │
└──────────────────────────────┘
```



## JSONExtractArrayRawCaseInsensitive <Badge intent="info" className="version-badge">v25.8+</Badge> [#JSONExtractArrayRawCaseInsensitive]


Returns an array with elements of JSON array, each represented as unparsed string, using case-insensitive key matching. This function is similar to [`JSONExtractArrayRaw`](#JSONExtractArrayRaw).
        

**Syntax**

```sql
JSONExtractArrayRawCaseInsensitive(json [, indices_or_keys]...)
```

**Arguments**

- `json` — JSON string to parse [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — Optional. Indices or keys to navigate to the array. Keys use case-insensitive matching [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns an array of raw JSON strings. [`Array(String)`](/sql-reference/data-types/array)

**Examples**

**basic**

```sql title=Query
SELECT JSONExtractArrayRawCaseInsensitive('{"Items": [1, 2, 3]}', 'ITEMS')
```

```response title=Response
['1','2','3']
```



## JSONExtractBool <Badge intent="info" className="version-badge">v20.1+</Badge> [#JSONExtractBool]


Parses JSON and extracts a value of Bool type.
        

**Syntax**

```sql
JSONExtractBool(json[, indices_or_keys, ...])
```

**Arguments**

- `json` — JSON string to parse. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — A list of zero or more arguments each of which can be either string or integer. [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns a Bool value if it exists, otherwise returns `0`. [`Bool`](/sql-reference/data-types/boolean)

**Examples**

**Usage example**

```sql title=Query
SELECT JSONExtractBool('{"passed": true}', 'passed') AS res;
```

```response title=Response
┌─res─┐
│   1 │
└─────┘
```



## JSONExtractBoolCaseInsensitive <Badge intent="info" className="version-badge">v25.8+</Badge> [#JSONExtractBoolCaseInsensitive]


Parses JSON and extracts a boolean value using case-insensitive key matching. This function is similar to [`JSONExtractBool`](#JSONExtractBool).
        

**Syntax**

```sql
JSONExtractBoolCaseInsensitive(json [, indices_or_keys]...)
```

**Arguments**

- `json` — JSON string to parse [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — Optional. Indices or keys to navigate to the field. Keys use case-insensitive matching [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns the extracted boolean value (1 for true, 0 for false), 0 if not found. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**basic**

```sql title=Query
SELECT JSONExtractBoolCaseInsensitive('{"IsActive": true}', 'isactive')
```

```response title=Response
1
```



## JSONExtractCaseInsensitive <Badge intent="info" className="version-badge">v25.8+</Badge> [#JSONExtractCaseInsensitive]


Parses JSON and extracts a value of the given ClickHouse data type using case-insensitive key matching. This function is similar to [`JSONExtract`](#JSONExtract).
        

**Syntax**

```sql
JSONExtractCaseInsensitive(json [, indices_or_keys...], return_type)
```

**Arguments**

- `json` — JSON string to parse [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — Optional. Indices or keys to navigate to the field. Keys use case-insensitive matching [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)
- `return_type` — The ClickHouse data type to extract [`String`](/sql-reference/data-types/string)


**Returned value**

Returns the extracted value in the specified data type. [`Any`](/sql-reference/data-types)

**Examples**

**int_type**

```sql title=Query
SELECT JSONExtractCaseInsensitive('{"Number": 123}', 'number', 'Int32')
```

```response title=Response
123
```

**array_type**

```sql title=Query
SELECT JSONExtractCaseInsensitive('{"List": [1, 2, 3]}', 'list', 'Array(Int32)')
```

```response title=Response
[1,2,3]
```



## JSONExtractFloat <Badge intent="info" className="version-badge">v20.1+</Badge> [#JSONExtractFloat]


Parses JSON and extracts a value of Float type.
        

**Syntax**

```sql
JSONExtractFloat(json[, indices_or_keys, ...])
```

**Arguments**

- `json` — JSON string to parse. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — A list of zero or more arguments each of which can be either string or integer. [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns a Float value if it exists, otherwise returns `0`. [`Float64`](/sql-reference/data-types/float)

**Examples**

**Usage example**

```sql title=Query
SELECT JSONExtractFloat('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', 2) AS res;
```

```response title=Response
┌─res─┐
│ 200 │
└─────┘
```



## JSONExtractFloatCaseInsensitive <Badge intent="info" className="version-badge">v25.8+</Badge> [#JSONExtractFloatCaseInsensitive]


Parses JSON and extracts a value of Float type using case-insensitive key matching. This function is similar to [`JSONExtractFloat`](#JSONExtractFloat).
        

**Syntax**

```sql
JSONExtractFloatCaseInsensitive(json [, indices_or_keys]...)
```

**Arguments**

- `json` — JSON string to parse [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — Optional. Indices or keys to navigate to the field. Keys use case-insensitive matching [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns the extracted Float value, 0 if not found or cannot be converted. [`Float64`](/sql-reference/data-types/float)

**Examples**

**basic**

```sql title=Query
SELECT JSONExtractFloatCaseInsensitive('{"Price": 12.34}', 'PRICE')
```

```response title=Response
12.34
```



## JSONExtractInt <Badge intent="info" className="version-badge">v20.1+</Badge> [#JSONExtractInt]


Parses JSON and extracts a value of Int type.
        

**Syntax**

```sql
JSONExtractInt(json[, indices_or_keys, ...])
```

**Arguments**

- `json` — JSON string to parse. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — A list of zero or more arguments each of which can be either string or integer. [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns an Int value if it exists, otherwise returns `0`. [`Int64`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT JSONExtractInt('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', 1) AS res;
```

```response title=Response
┌─res─┐
│ 200 │
└─────┘
```



## JSONExtractIntCaseInsensitive <Badge intent="info" className="version-badge">v25.8+</Badge> [#JSONExtractIntCaseInsensitive]


Parses JSON and extracts a value of Int type using case-insensitive key matching. This function is similar to [`JSONExtractInt`](#JSONExtractInt).
        

**Syntax**

```sql
JSONExtractIntCaseInsensitive(json [, indices_or_keys]...)
```

**Arguments**

- `json` — JSON string to parse [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — Optional. Indices or keys to navigate to the field. Keys use case-insensitive matching [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns the extracted Int value, 0 if not found or cannot be converted. [`Int64`](/sql-reference/data-types/int-uint)

**Examples**

**basic**

```sql title=Query
SELECT JSONExtractIntCaseInsensitive('{"Value": 123}', 'value')
```

```response title=Response
123
```

**nested**

```sql title=Query
SELECT JSONExtractIntCaseInsensitive('{"DATA": {"COUNT": 42}}', 'data', 'Count')
```

```response title=Response
42
```



## JSONExtractKeys <Badge intent="info" className="version-badge">v21.11+</Badge> [#JSONExtractKeys]


Parses a JSON string and extracts the keys.
        

**Syntax**

```sql
JSONExtractKeys(json[, indices_or_keys, ...])
```

**Arguments**

- `json` — JSON string to parse. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — A list of zero or more arguments each of which can be either string or integer. [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns an array with the keys of the JSON object. [`Array(String)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT JSONExtractKeys('{"a": "hello", "b": [-100, 200.0, 300]}') AS res;
```

```response title=Response
┌─res─────────┐
│ ['a','b']   │
└─────────────┘
```



## JSONExtractKeysAndValues <Badge intent="info" className="version-badge">v20.1+</Badge> [#JSONExtractKeysAndValues]


Parses key-value pairs from a JSON where the values are of the given ClickHouse data type.
        

**Syntax**

```sql
JSONExtractKeysAndValues(json[, indices_or_keys, ...], value_type)
```

**Arguments**

- `json` — JSON string to parse. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — A list of zero or more arguments each of which can be either string or integer. [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)
- `value_type` — ClickHouse data type of the values. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns an array of tuples with the parsed key-value pairs. [`Array(Tuple(String, value_type))`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT JSONExtractKeysAndValues('{"x": {"a": 5, "b": 7, "c": 11}}', 'Int8', 'x') AS res;
```

```response title=Response
┌─res────────────────────┐
│ [('a',5),('b',7),('c',11)] │
└────────────────────────┘
```



## JSONExtractKeysAndValuesCaseInsensitive <Badge intent="info" className="version-badge">v25.8+</Badge> [#JSONExtractKeysAndValuesCaseInsensitive]


Parses key-value pairs from JSON using case-insensitive key matching. This function is similar to [`JSONExtractKeysAndValues`](#JSONExtractKeysAndValues).
        

**Syntax**

```sql
JSONExtractKeysAndValuesCaseInsensitive(json [, indices_or_keys...], value_type)
```

**Arguments**

- `json` — JSON string to parse [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — Optional. Indices or keys to navigate to the object. Keys use case-insensitive matching [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)
- `value_type` — The ClickHouse data type of the values [`String`](/sql-reference/data-types/string)


**Returned value**

Returns an array of tuples containing key-value pairs. [`Array(Tuple(String, T))`](/sql-reference/data-types/array)

**Examples**

**basic**

```sql title=Query
SELECT JSONExtractKeysAndValuesCaseInsensitive('{"Name": "Alice", "AGE": 30}', 'String')
```

```response title=Response
[('Name','Alice'),('AGE','30')]
```



## JSONExtractKeysAndValuesRaw <Badge intent="info" className="version-badge">v20.4+</Badge> [#JSONExtractKeysAndValuesRaw]


Returns an array of tuples with keys and values from a JSON object. All values are represented as unparsed strings.
        

**Syntax**

```sql
JSONExtractKeysAndValuesRaw(json[, indices_or_keys, ...])
```

**Arguments**

- `json` — JSON string to parse. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — A list of zero or more arguments each of which can be either string or integer. [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns an array of tuples with parsed key-value pairs where values are unparsed strings. [`Array(Tuple(String, String))`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
SELECT JSONExtractKeysAndValuesRaw('{"a": [-100, 200.0], "b": "hello"}') AS res;
```

```response title=Response
┌─res──────────────────────────────────┐
│ [('a','[-100,200.0]'),('b','"hello"')] │
└──────────────────────────────────────┘
```



## JSONExtractKeysAndValuesRawCaseInsensitive <Badge intent="info" className="version-badge">v25.8+</Badge> [#JSONExtractKeysAndValuesRawCaseInsensitive]


Extracts raw key-value pairs from JSON using case-insensitive key matching. This function is similar to [`JSONExtractKeysAndValuesRaw`](#JSONExtractKeysAndValuesRaw).
        

**Syntax**

```sql
JSONExtractKeysAndValuesRawCaseInsensitive(json [, indices_or_keys]...)
```

**Arguments**

- `json` — JSON string to parse [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — Optional. Indices or keys to navigate to the object. Keys use case-insensitive matching [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns an array of tuples containing key-value pairs as raw strings. [`Array(Tuple(String, String))`](/sql-reference/data-types/array)

**Examples**

**basic**

```sql title=Query
SELECT JSONExtractKeysAndValuesRawCaseInsensitive('{"Name": "Alice", "AGE": 30}')
```

```response title=Response
[('Name','"Alice"'),('AGE','30')]
```



## JSONExtractKeysCaseInsensitive <Badge intent="info" className="version-badge">v25.8+</Badge> [#JSONExtractKeysCaseInsensitive]


Parses a JSON string and extracts the keys using case-insensitive key matching to navigate to nested objects. This function is similar to [`JSONExtractKeys`](#JSONExtractKeys).
        

**Syntax**

```sql
JSONExtractKeysCaseInsensitive(json [, indices_or_keys]...)
```

**Arguments**

- `json` — JSON string to parse [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — Optional. Indices or keys to navigate to the object. Keys use case-insensitive matching [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns an array of keys from the JSON object. [`Array(String)`](/sql-reference/data-types/array)

**Examples**

**basic**

```sql title=Query
SELECT JSONExtractKeysCaseInsensitive('{"Name": "Alice", "AGE": 30}')
```

```response title=Response
['Name','AGE']
```

**nested**

```sql title=Query
SELECT JSONExtractKeysCaseInsensitive('{"User": {"name": "John", "AGE": 25}}', 'user')
```

```response title=Response
['name','AGE']
```



## JSONExtractRaw <Badge intent="info" className="version-badge">v20.1+</Badge> [#JSONExtractRaw]


Returns a part of JSON as unparsed string.
        

**Syntax**

```sql
JSONExtractRaw(json[, indices_or_keys, ...])
```

**Arguments**

- `json` — JSON string to parse. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — A list of zero or more arguments each of which can be either string or integer. [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns the part of JSON as an unparsed string. If the part does not exist or has a wrong type, an empty string will be returned. [`String`](/sql-reference/data-types/string)

**Examples**

**Usage example**

```sql title=Query
SELECT JSONExtractRaw('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') AS res;
```

```response title=Response
┌─res──────────────┐
│ [-100,200.0,300] │
└──────────────────┘
```



## JSONExtractRawCaseInsensitive <Badge intent="info" className="version-badge">v25.8+</Badge> [#JSONExtractRawCaseInsensitive]


Returns part of the JSON as an unparsed string using case-insensitive key matching. This function is similar to [`JSONExtractRaw`](#JSONExtractRaw).
        

**Syntax**

```sql
JSONExtractRawCaseInsensitive(json [, indices_or_keys]...)
```

**Arguments**

- `json` — JSON string to parse [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — Optional. Indices or keys to navigate to the field. Keys use case-insensitive matching [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns the raw JSON string of the extracted element. [`String`](/sql-reference/data-types/string)

**Examples**

**object**

```sql title=Query
SELECT JSONExtractRawCaseInsensitive('{"Object": {"key": "value"}}', 'OBJECT')
```

```response title=Response
{"key":"value"}
```



## JSONExtractString <Badge intent="info" className="version-badge">v20.1+</Badge> [#JSONExtractString]


Parses JSON and extracts a value of String type.
        

**Syntax**

```sql
JSONExtractString(json[, indices_or_keys, ...])
```

**Arguments**

- `json` — JSON string to parse. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — A list of zero or more arguments each of which can be either string or integer. [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns a String value if it exists, otherwise returns an empty string. [`String`](/sql-reference/data-types/string)

**Examples**

**Usage example**

```sql title=Query
SELECT JSONExtractString('{"a": "hello", "b": [-100, 200.0, 300]}', 'a') AS res;
```

```response title=Response
┌─res───┐
│ hello │
└───────┘
```



## JSONExtractStringCaseInsensitive <Badge intent="info" className="version-badge">v25.8+</Badge> [#JSONExtractStringCaseInsensitive]


Parses JSON and extracts a string using case-insensitive key matching. This function is similar to [`JSONExtractString`](#JSONExtractString).
        

**Syntax**

```sql
JSONExtractStringCaseInsensitive(json [, indices_or_keys]...)
```

**Arguments**

- `json` — JSON string to parse [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — Optional. Indices or keys to navigate to the field. Keys use case-insensitive matching [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns the extracted string value, empty string if not found. [`String`](/sql-reference/data-types/string)

**Examples**

**basic**

```sql title=Query
SELECT JSONExtractStringCaseInsensitive('{"ABC": "def"}', 'abc')
```

```response title=Response
def
```

**nested**

```sql title=Query
SELECT JSONExtractStringCaseInsensitive('{"User": {"Name": "John"}}', 'user', 'name')
```

```response title=Response
John
```



## JSONExtractUInt <Badge intent="info" className="version-badge">v20.1+</Badge> [#JSONExtractUInt]


Parses JSON and extracts a value of UInt type.
        

**Syntax**

```sql
JSONExtractUInt(json [, indices_or_keys, ...])
```

**Arguments**

- `json` — JSON string to parse. [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — A list of zero or more arguments each of which can be either string or integer. [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns a UInt value if it exists, otherwise returns `0`. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT JSONExtractUInt('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', -1) AS res;
```

```response title=Response
┌─res─┐
│ 300 │
└─────┘
```



## JSONExtractUIntCaseInsensitive <Badge intent="info" className="version-badge">v25.8+</Badge> [#JSONExtractUIntCaseInsensitive]


Parses JSON and extracts a value of UInt type using case-insensitive key matching. This function is similar to [`JSONExtractUInt`](#JSONExtractUInt).
        

**Syntax**

```sql
JSONExtractUIntCaseInsensitive(json [, indices_or_keys]...)
```

**Arguments**

- `json` — JSON string to parse [`String`](/sql-reference/data-types/string)
- `indices_or_keys` — Optional. Indices or keys to navigate to the field. Keys use case-insensitive matching [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns the extracted UInt value, 0 if not found or cannot be converted. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**basic**

```sql title=Query
SELECT JSONExtractUIntCaseInsensitive('{"COUNT": 789}', 'count')
```

```response title=Response
789
```



## JSONHas <Badge intent="info" className="version-badge">v20.1+</Badge> [#JSONHas]


Checks for the existence of the provided value(s) in the JSON document.
        

**Syntax**

```sql
JSONHas(json[ ,indices_or_keys, ...])
```

**Arguments**

- `json` — JSON string to parse [`String`](/sql-reference/data-types/string)
- `[ ,indices_or_keys, ...]` — A list of zero or more arguments. [`String`](/sql-reference/data-types/string) or [`(U)Int*`](/sql-reference/data-types/int-uint)


**Returned value**

Returns `1` if the value exists in `json`, otherwise `0` [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') = 1;
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 'b', 4) = 0;
```

```response title=Response
1
0
```



## JSONLength <Badge intent="info" className="version-badge">v20.1+</Badge> [#JSONLength]


Return the length of a JSON array or a JSON object.
If the value does not exist or has the wrong type, `0` will be returned.
        

**Syntax**

```sql
JSONLength(json [, indices_or_keys, ...])
```

**Arguments**

- `json` — JSON string to parse [`String`](/sql-reference/data-types/string)
- `[, indices_or_keys, ...]` — Optional. A list of zero or more arguments. [`String`](/sql-reference/data-types/string) or [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)


**Returned value**

Returns the length of the JSON array or JSON object, otherwise returns `0` if the value does not exist or has the wrong type. [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT JSONLength('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') = 3;
SELECT JSONLength('{"a": "hello", "b": [-100, 200.0, 300]}') = 2;
```

```response title=Response
1
1
```



## JSONMergePatch <Badge intent="info" className="version-badge">v23.10+</Badge> [#JSONMergePatch]


Returns the merged JSON object string which is formed by merging multiple JSON objects.
    

**Syntax**

```sql
jsonMergePatch(json1[, json2, ...])
```

**Aliases**: `jsonMergePatch`

**Arguments**

- `json1[, json2, ...]` — One or more strings with valid JSON. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns the merged JSON object string, if the JSON object strings are valid. [`String`](/sql-reference/data-types/string)

**Examples**

**Usage example**

```sql title=Query
SELECT jsonMergePatch('{"a":1}', '{"name": "joey"}', '{"name": "tom"}', '{"name": "zoey"}') AS res;
```

```response title=Response
┌─res───────────────────┐
│ {"a":1,"name":"zoey"} │
└───────────────────────┘
```



## JSONSharedDataPaths <Badge intent="info" className="version-badge">v24.8+</Badge> [#JSONSharedDataPaths]


Returns the list of paths that are stored in shared data structure in JSON column.
        

**Syntax**

```sql
JSONSharedDataPaths(json)
```

**Arguments**

- `json` — JSON column. [`JSON`](/sql-reference/data-types/newjson)


**Returned value**

Returns an array of paths stored in shared data structure in the JSON column. [`Array(String)`](/sql-reference/data-types/array)

**Examples**

**Usage example**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONSharedDataPaths(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONSharedDataPaths(json)─┐
│ {"a":"42"}                           │ []                        │
│ {"b":"Hello"}                        │ ['b']                     │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ ['c']                     │
└──────────────────────────────────────┴───────────────────────────┘
```



## JSONSharedDataPathsWithTypes <Badge intent="info" className="version-badge">v24.8+</Badge> [#JSONSharedDataPathsWithTypes]


Returns the list of paths that are stored in shared data structure and their types in each row in JSON column.
        

**Syntax**

```sql
JSONSharedDataPathsWithTypes(json)
```

**Arguments**

- `json` — JSON column. [`JSON`](/sql-reference/data-types/newjson)


**Returned value**

Returns a map of paths stored in shared data structure and their data types in the JSON column. [`Map(String, String)`](/sql-reference/data-types/map)

**Examples**

**Usage example**

```sql title=Query
CREATE TABLE test (json JSON(max_dynamic_paths=1)) ENGINE = Memory;
INSERT INTO test FORMAT JSONEachRow {"json" : {"a" : 42}}, {"json" : {"b" : "Hello"}}, {"json" : {"a" : [1, 2, 3], "c" : "2020-01-01"}}
SELECT json, JSONSharedDataPathsWithTypes(json) FROM test;
```

```response title=Response
┌─json─────────────────────────────────┬─JSONSharedDataPathsWithTypes(json)─┐
│ {"a":"42"}                           │ {}                                  │
│ {"b":"Hello"}                        │ {'b':'String'}                      │
│ {"a":["1","2","3"],"c":"2020-01-01"} │ {'c':'Date'}                        │
└──────────────────────────────────────┴─────────────────────────────────────┘
```



## JSONType <Badge intent="info" className="version-badge">v20.1+</Badge> [#JSONType]


Return the type of a JSON value. If the value does not exist, `Null=0` will be returned.
        

**Syntax**

```sql
JSONType(json[, indices_or_keys, ...])
```

**Arguments**

- `json` — JSON string to parse [`String`](/sql-reference/data-types/string)
- `json[, indices_or_keys, ...]` — A list of zero or more arguments, each of which can be either string or integer. [`String`](/sql-reference/data-types/string) or [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint)


**Returned value**

Returns the type of a JSON value as a string, otherwise if the value doesn't exist it returns `Null=0` [`Enum`](/sql-reference/data-types/enum)

**Examples**

**Usage example**

```sql title=Query
SELECT JSONType('{"a": "hello", "b": [-100, 200.0, 300]}') = 'Object';
SELECT JSONType('{"a": "hello", "b": [-100, 200.0, 300]}', 'a') = 'String';
SELECT JSONType('{"a": "hello", "b": [-100, 200.0, 300]}', 'b') = 'Array';
```

```response title=Response
1
1
1
```



## JSON_EXISTS <Badge intent="info" className="version-badge">v21.8+</Badge> [#JSON_EXISTS]


If the value exists in the JSON document, `1` will be returned.
If the value does not exist, `0` will be returned.
        

**Syntax**

```sql
JSON_EXISTS(json, path)
```

**Arguments**

- `json` — A string with valid JSON. [`String`](/sql-reference/data-types/string)
- `path` — A string representing the path. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns `1` if the value exists in the JSON document, otherwise `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT JSON_EXISTS('{"hello":1}', '$.hello');
SELECT JSON_EXISTS('{"hello":{"world":1}}', '$.hello.world');
SELECT JSON_EXISTS('{"hello":["world"]}', '$.hello[*]');
SELECT JSON_EXISTS('{"hello":["world"]}', '$.hello[0]');
```

```response title=Response
┌─JSON_EXISTS(⋯ '$.hello')─┐
│                        1 │
└──────────────────────────┘
┌─JSON_EXISTS(⋯llo.world')─┐
│                        1 │
└──────────────────────────┘
┌─JSON_EXISTS(⋯.hello[*]')─┐
│                        1 │
└──────────────────────────┘
┌─JSON_EXISTS(⋯.hello[0]')─┐
│                        1 │
└──────────────────────────┘
```



## JSON_QUERY <Badge intent="info" className="version-badge">v21.8+</Badge> [#JSON_QUERY]


Parses a JSON and extract a value as a JSON array or JSON object.
If the value does not exist, an empty string will be returned.
        

**Syntax**

```sql
JSON_QUERY(json, path)
```

**Arguments**

- `json` — A string with valid JSON. [`String`](/sql-reference/data-types/string)
- `path` — A string representing the path. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns the extracted JSON array or JSON object as a string, or an empty string if the value does not exist. [`String`](/sql-reference/data-types/string)

**Examples**

**Usage example**

```sql title=Query
SELECT JSON_QUERY('{"hello":"world"}', '$.hello');
SELECT JSON_QUERY('{"array":[[0, 1, 2, 3, 4, 5], [0, -1, -2, -3, -4, -5]]}', '$.array[*][0 to 2, 4]');
SELECT JSON_QUERY('{"hello":2}', '$.hello');
SELECT toTypeName(JSON_QUERY('{"hello":2}', '$.hello'));
```

```response title=Response
["world"]
[0, 1, 4, 0, -1, -4]
[2]
String
```



## JSON_VALUE <Badge intent="info" className="version-badge">v21.11+</Badge> [#JSON_VALUE]


Parses a JSON and extract a value as a JSON scalar. If the value does not exist, an empty string will be returned by default.

This function is controlled by the following settings:
- by SET `function_json_value_return_type_allow_nullable` = `true`, `NULL` will be returned. If the value is complex type (such as: struct, array, map), an empty string will be returned by default.
- by SET `function_json_value_return_type_allow_complex` = `true`, the complex value will be returned.
        

**Syntax**

```sql
JSON_VALUE(json, path)
```

**Arguments**

- `json` — A string with valid JSON. [`String`](/sql-reference/data-types/string)
- `path` — A string representing the path. [`String`](/sql-reference/data-types/string)


**Returned value**

Returns the extracted JSON scalar as a string, or an empty string if the value does not exist. [`String`](/sql-reference/data-types/string)

**Examples**

**Usage example**

```sql title=Query
SELECT JSON_VALUE('{"hello":"world"}', '$.hello');
SELECT JSON_VALUE('{"array":[[0, 1, 2, 3, 4, 5], [0, -1, -2, -3, -4, -5]]}', '$.array[*][0 to 2, 4]');
SELECT JSON_VALUE('{"hello":2}', '$.hello');
SELECT JSON_VALUE('{"hello":"world"}', '$.b') settings function_json_value_return_type_allow_nullable=true;
```

```response title=Response
world
0
2
ᴺᵁᴸᴸ
```



## dynamicElement <Badge intent="info" className="version-badge">v24.1+</Badge> [#dynamicElement]


Extracts a column with specified type from a `Dynamic` column.

This function allows you to extract values of a specific type from a Dynamic column. If a row contains a value
of the requested type, it returns that value. If the row contains a different type or NULL, it returns NULL
for scalar types or an empty array for array types.
    

**Syntax**

```sql
dynamicElement(dynamic, type_name)
```

**Arguments**

- `dynamic` — Dynamic column to extract from. [`Dynamic`](/sql-reference/data-types/dynamic)
- `type_name` — The name of the variant type to extract (e.g., 'String', 'Int64', 'Array(Int64)'). 

**Returned value**

Returns values of the specified type from the Dynamic column. Returns NULL for non-matching types (or empty array for array types). [`Any`](/sql-reference/data-types)

**Examples**

**Extracting different types from Dynamic column**

```sql title=Query
CREATE TABLE test (d Dynamic) ENGINE = Memory;
INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);
SELECT d, dynamicType(d), dynamicElement(d, 'String'), dynamicElement(d, 'Int64'), dynamicElement(d, 'Array(Int64)'), dynamicElement(d, 'Date'), dynamicElement(d, 'Array(String)') FROM test
```

```response title=Response
┌─d─────────────┬─dynamicType(d)─┬─dynamicElement(d, 'String')─┬─dynamicElement(d, 'Int64')─┬─dynamicElement(d, 'Array(Int64)')─┬─dynamicElement(d, 'Date')─┬─dynamicElement(d, 'Array(String)')─┐
│ ᴺᵁᴸᴸ          │ None           │ ᴺᵁᴸᴸ                        │                       ᴺᵁᴸᴸ │ []                                │                      ᴺᵁᴸᴸ │ []                                 │
│ 42            │ Int64          │ ᴺᵁᴸᴸ                        │                         42 │ []                                │                      ᴺᵁᴸᴸ │ []                                 │
│ Hello, World! │ String         │ Hello, World!               │                       ᴺᵁᴸᴸ │ []                                │                      ᴺᵁᴸᴸ │ []                                 │
│ [1,2,3]       │ Array(Int64)   │ ᴺᵁᴸᴸ                        │                       ᴺᵁᴸᴸ │ [1,2,3]                           │                      ᴺᵁᴸᴸ │ []                                 │
└───────────────┴────────────────┴─────────────────────────────┴────────────────────────────┴───────────────────────────────────┴───────────────────────────┴────────────────────────────────────┘
```



## dynamicType <Badge intent="info" className="version-badge">v24.1+</Badge> [#dynamicType]


Returns the variant type name for each row of a `Dynamic` column.

For rows containing NULL, the function returns 'None'. For all other rows, it returns the actual data type
stored in that row of the Dynamic column (e.g., 'Int64', 'String', 'Array(Int64)').


**Syntax**

```sql
dynamicType(dynamic)
```

**Arguments**

- `dynamic` — Dynamic column to inspect. [`Dynamic`](/sql-reference/data-types/dynamic)


**Returned value**

Returns the type name of the value stored in each row, or 'None' for NULL values. [`String`](/sql-reference/data-types/string)

**Examples**

**Inspecting types in Dynamic column**

```sql title=Query
CREATE TABLE test (d Dynamic) ENGINE = Memory;
INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);
SELECT d, dynamicType(d) FROM test;
```

```response title=Response
┌─d─────────────┬─dynamicType(d)─┐
│ ᴺᵁᴸᴸ          │ None           │
│ 42            │ Int64          │
│ Hello, World! │ String         │
│ [1,2,3]       │ Array(Int64)   │
└───────────────┴────────────────┘
```



## isDynamicElementInSharedData <Badge intent="info" className="version-badge">v24.1+</Badge> [#isDynamicElementInSharedData]


Returns true for rows in a Dynamic column that are stored in shared variant format rather than as separate subcolumns.

When a Dynamic column has a `max_types` limit, values that exceed this limit are stored in a shared binary format
instead of being separated into individual typed subcolumns. This function identifies which rows are stored in this shared format.
    

**Syntax**

```sql
isDynamicElementInSharedData(dynamic)
```

**Arguments**

- `dynamic` — Dynamic column to inspect. [`Dynamic`](/sql-reference/data-types/dynamic)


**Returned value**

Returns true if the value is stored in shared variant format, false if stored as a separate subcolumn or is NULL. [`Bool`](/sql-reference/data-types/boolean)

**Examples**

**Checking storage format in Dynamic column with max_types limit**

```sql title=Query
CREATE TABLE test (d Dynamic(max_types=2)) ENGINE = Memory;
INSERT INTO test VALUES (NULL), (42), ('Hello, World!'), ([1, 2, 3]);
SELECT d, isDynamicElementInSharedData(d) FROM test;
```

```response title=Response
┌─d─────────────┬─isDynamicElementInSharedData(d)─┐
│ ᴺᵁᴸᴸ          │ false                           │
│ 42            │ false                           │
│ Hello, World! │ true                            │
│ [1,2,3]       │ true                            │
└───────────────┴─────────────────────────────────┘
```



## isValidJSON <Badge intent="info" className="version-badge">v20.1+</Badge> [#isValidJSON]


Checks that the string passed is valid JSON.
        

**Syntax**

```sql
isValidJSON(json)
```

**Arguments**

- `json` — JSON string to validate [`String`](/sql-reference/data-types/string)


**Returned value**

Returns `1` if the string is valid JSON, otherwise `0`. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT isValidJSON('{"a": "hello", "b": [-100, 200.0, 300]}') = 1;
SELECT isValidJSON('not JSON') = 0;
```

```response title=Response
1
0
```

**Using integers to access both JSON arrays and JSON objects**

```sql title=Query
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 0);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 1);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 2);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', -1);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', -2);
SELECT JSONHas('{"a": "hello", "b": [-100, 200.0, 300]}', 3);
```

```response title=Response
0
1
1
1
1
1
0
```



## simpleJSONExtractBool <Badge intent="info" className="version-badge">v21.4+</Badge> [#simpleJSONExtractBool]


Parses a true/false value from the value of the field named `field_name`.
The result is `UInt8`.


**Syntax**

```sql
simpleJSONExtractBool(json, field_name)
```

**Aliases**: `visitParamExtractBool`

**Arguments**

- `json` — The JSON in which the field is searched for. [`String`](/sql-reference/data-types/string)
- `field_name` — The name of the field to search for. [`const String`](/sql-reference/data-types/string)


**Returned value**

Returns `1` if the value of the field is `true`, `0` otherwise. This means this function will return `0` including (and not only) in the following cases:
- If the field doesn't exists.
- If the field contains `true` as a string, e.g.: `{"field":"true"}`.
- If the field contains `1` as a numerical value. [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":false,"bar":true}');
INSERT INTO jsons VALUES ('{"foo":"true","qux":1}');

SELECT simpleJSONExtractBool(json, 'bar') FROM jsons ORDER BY json;
SELECT simpleJSONExtractBool(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
0
1
0
0
```



## simpleJSONExtractFloat <Badge intent="info" className="version-badge">v21.4+</Badge> [#simpleJSONExtractFloat]


Parses `Float64` from the value of the field named `field_name`.
If `field_name` is a string field, it tries to parse a number from the beginning of the string.
If the field does not exist, or it exists but does not contain a number, it returns `0`.


**Syntax**

```sql
simpleJSONExtractFloat(json, field_name)
```

**Aliases**: `visitParamExtractFloat`

**Arguments**

- `json` — The JSON in which the field is searched for. [`String`](/sql-reference/data-types/string)
- `field_name` — The name of the field to search for. [`const String`](/sql-reference/data-types/string)


**Returned value**

Returns the number parsed from the field if the field exists and contains a number, otherwise `0`. [`Float64`](/sql-reference/data-types/float)

**Examples**

**Usage example**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"-4e3"}');
INSERT INTO jsons VALUES ('{"foo":-3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":"not1number"}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractFloat(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
0
-4000
0
-3.4
5
```



## simpleJSONExtractInt <Badge intent="info" className="version-badge">v21.4+</Badge> [#simpleJSONExtractInt]


Parses `Int64` from the value of the field named `field_name`.
If `field_name` is a string field, it tries to parse a number from the beginning of the string.
If the field does not exist, or it exists but does not contain a number, it returns `0`.


**Syntax**

```sql
simpleJSONExtractInt(json, field_name)
```

**Aliases**: `visitParamExtractInt`

**Arguments**

- `json` — The JSON in which the field is searched for. [`String`](/sql-reference/data-types/string)
- `field_name` — The name of the field to search for. [`const String`](/sql-reference/data-types/string)


**Returned value**

Returns the number parsed from the field if the field exists and contains a number, `0` otherwise [`Int64`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"-4e3"}');
INSERT INTO jsons VALUES ('{"foo":-3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":"not1number"}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractInt(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
0
-4
0
-3
5
```



## simpleJSONExtractRaw <Badge intent="info" className="version-badge">v21.4+</Badge> [#simpleJSONExtractRaw]


Returns the value of the field named `field_name` as a `String`, including separators.


**Syntax**

```sql
simpleJSONExtractRaw(json, field_name)
```

**Aliases**: `visitParamExtractRaw`

**Arguments**

- `json` — The JSON in which the field is searched for. [`String`](/sql-reference/data-types/string)
- `field_name` — The name of the field to search for. [`const String`](/sql-reference/data-types/string)


**Returned value**

Returns the value of the field as a string, including separators if the field exists, or an empty string otherwise [`String`](/sql-reference/data-types/string)

**Examples**

**Usage example**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"-4e3"}');
INSERT INTO jsons VALUES ('{"foo":-3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":{"def":[1,2,3]}}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractRaw(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
"-4e3"
-3.4
5
{"def":[1,2,3]}
```



## simpleJSONExtractString <Badge intent="info" className="version-badge">v21.4+</Badge> [#simpleJSONExtractString]


Parses `String` in double quotes from the value of the field named `field_name`.

**Implementation details**

There is currently no support for code points in the format `\uXXXX\uYYYY` that are not from the basic multilingual plane (they are converted to CESU-8 instead of UTF-8).


**Syntax**

```sql
simpleJSONExtractString(json, field_name)
```

**Aliases**: `visitParamExtractString`

**Arguments**

- `json` — The JSON in which the field is searched for. [`String`](/sql-reference/data-types/string)
- `field_name` — The name of the field to search for. [`const String`](/sql-reference/data-types/string)


**Returned value**

Returns the unescaped value of a field as a string, including separators. An empty string is returned if the field doesn't contain a double quoted string, if unescaping fails or if the field doesn't exist [`String`](/sql-reference/data-types/string)

**Examples**

**Usage example**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"\\n\\u0000"}');
INSERT INTO jsons VALUES ('{"foo":"\\u263"}');
INSERT INTO jsons VALUES ('{"foo":"\\u263a"}');
INSERT INTO jsons VALUES ('{"foo":"hello}');

SELECT simpleJSONExtractString(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
\n\0

☺
```



## simpleJSONExtractUInt <Badge intent="info" className="version-badge">v21.4+</Badge> [#simpleJSONExtractUInt]


Parses `UInt64` from the value of the field named `field_name`.
If `field_name` is a string field, it tries to parse a number from the beginning of the string.
If the field does not exist, or it exists but does not contain a number, it returns `0`.


**Syntax**

```sql
simpleJSONExtractUInt(json, field_name)
```

**Aliases**: `visitParamExtractUInt`

**Arguments**

- `json` — The JSON in which the field is searched for. [`String`](/sql-reference/data-types/string)
- `field_name` — The name of the field to search for. [`const String`](/sql-reference/data-types/string)


**Returned value**

Returns the number parsed from the field if the field exists and contains a number, `0` otherwise [`UInt64`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"4e3"}');
INSERT INTO jsons VALUES ('{"foo":3.4}');
INSERT INTO jsons VALUES ('{"foo":5}');
INSERT INTO jsons VALUES ('{"foo":"not1number"}');
INSERT INTO jsons VALUES ('{"baz":2}');

SELECT simpleJSONExtractUInt(json, 'foo') FROM jsons ORDER BY json;
```

```response title=Response
0
4
0
3
5
```



## simpleJSONHas <Badge intent="info" className="version-badge">v21.4+</Badge> [#simpleJSONHas]


Checks whether there is a field named `field_name`.


**Syntax**

```sql
simpleJSONHas(json, field_name)
```

**Aliases**: `visitParamHas`

**Arguments**

- `json` — The JSON in which the field is searched for. [`String`](/sql-reference/data-types/string)
- `field_name` — The name of the field to search for. [`const String`](/sql-reference/data-types/string)


**Returned value**

Returns `1` if the field exists, `0` otherwise [`UInt8`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
CREATE TABLE jsons
(
    `json` String
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO jsons VALUES ('{"foo":"true","qux":1}');

SELECT simpleJSONHas(json, 'foo') FROM jsons;
SELECT simpleJSONHas(json, 'bar') FROM jsons;
```

```response title=Response
1
0
```



## toJSONString <Badge intent="info" className="version-badge">v21.7+</Badge> [#toJSONString]


Serializes a value to its JSON representation. Various data types and nested structures are supported.
64-bit [integers](../data-types/int-uint.md) or bigger (like `UInt64` or `Int128`) are enclosed in quotes by default. [output_format_json_quote_64bit_integers](/operations/settings/formats#output_format_json_quote_64bit_integers) controls this behavior.
Special values `NaN` and `inf` are replaced with `null`. Enable [output_format_json_quote_denormals](/operations/settings/formats#output_format_json_quote_denormals) setting to show them.
When serializing an [Enum](../data-types/enum.md) value, the function outputs its name.

See also:
- [output_format_json_quote_64bit_integers](/operations/settings/formats#output_format_json_quote_64bit_integers)
- [output_format_json_quote_denormals](/operations/settings/formats#output_format_json_quote_denormals)
    

**Syntax**

```sql
toJSONString(value)
```

**Arguments**

- `value` — Value to serialize. Value may be of any data type. [`Any`](/sql-reference/data-types)


**Returned value**

Returns the JSON representation of the value. [`String`](/sql-reference/data-types/string)

**Examples**

**Map serialization**

```sql title=Query
SELECT toJSONString(map('key1', 1, 'key2', 2));
```

```response title=Response
┌─toJSONString(map('key1', 1, 'key2', 2))─┐
│ {"key1":1,"key2":2}                     │
└─────────────────────────────────────────┘
```

**Special values**

```sql title=Query
SELECT toJSONString(tuple(1.25, NULL, NaN, +inf, -inf, [])) SETTINGS output_format_json_quote_denormals = 1;
```

```response title=Response
┌─toJSONString(tuple(1.25, NULL, NaN, plus(inf), minus(inf), []))─┐
│ [1.25,null,"nan","inf","-inf",[]]                               │
└─────────────────────────────────────────────────────────────────┘
```



{/* <!--AUTOGENERATED_END--> */}
