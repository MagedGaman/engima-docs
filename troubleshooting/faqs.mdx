---
title: "Frequently Asked Questions"
description: "Answers to common questions about WebRun's browser automation platform"
icon: "circle-question"
---

## General Questions

### What browsers does WebRun use?

WebRun uses **Chrome Desktop** running in cloud-based instances. Each session gets a dedicated browser instance with:

- **Version:** Latest stable Official Chrome
- **User Agent:** Standard Chrome user agent
- **Extensions:** Cookie blocker
- **Cookies:** Isolated per session
- **JavaScript:** Enabled by default

**Note:** You cannot currently specify browser type (Firefox, Safari, etc.) or version. All sessions uses Chrome.

**Related:**
- [Browser Specifications](/concepts/browser-specs)
- [Session Configuration](/api-reference/sessions/start-session)

---

### How long can sessions run?

Session duration depends on your configuration:

**Default Limits:**
- **Minimum duration:** 1 minutes (60,000ms)
- **Maximum duration:** Unlimited
- **Default if not specified:** 5 minutes (300,000ms)

**Inactivity Timeout:**
- Sessions expire after the `maxDuration` is reached
- No automatic extension - you must create a new session

**Example:**
```javascript
// Session that can run up to 10 minutes
const session = await fetch("https://connect.webrun.ai/start/start-session", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "Authorization": `Bearer ${apiKey}`
  },
  body: JSON.stringify({
    taskDetails: "Long-running task",
    maxDuration: 600000 // 10 minutes - requires higher tier plan
  })
});
```

**Plan-Specific Limits:**
- **Free Tier:** Max 5 minutes (300,000ms)
- **Pro Tier:** Max 15 minutes (900,000ms)
- **Enterprise:** Custom limits available

**Related:**
- [Session Lifecycle](/concepts/sessions#lifecycle)
- [Pricing Plans](/pricing)

---

### Is my data secure?

Yes, WebRun takes security seriously:

**Session Isolation:**
- Each session runs in an isolated browser instance
- Cookies and localStorage are not shared between sessions
- Instances are destroyed after session termination

**Data Handling:**
- API keys are encrypted in transit and at rest
- Session data is stored temporarily for debugging
- Logs are automatically deleted after 30 days

**Network Security:**
- All API communication uses HTTPS/TLS 1.3
- WebSocket connections are encrypted (WSS)
- No data is transmitted in plaintext

**Privacy:**
- WebRun does not store credentials you provide to websites
- Screenshots and recordings are deleted with the session
- We do not track or log browsing behavior

**Compliance:**
- GDPR compliant
- Data residency options available for Enterprise

**Best Practices:**
- Rotate API keys regularly
- Don't hardcode credentials in your code
- Use environment variables for sensitive data
- Terminate sessions immediately when done

**Related:**
- [Security Overview](/essentials/security)
- [Privacy Policy](https://webrun.ai/privacy)

---

### Can I run parallel sessions?

Yes, but with limits based on your plan:

**Concurrent Session Limits:**
- **Free Tier:** 2 concurrent sessions
- **Pro Tier:** 15 concurrent sessions
- **Enterprise:** Custom limits

**Example:**
```javascript
// Run multiple sessions in parallel
const sessions = await Promise.all([
  createSession("Task 1", apiKey),
  createSession("Task 2", apiKey),
  createSession("Task 3", apiKey)
]);

console.log("Created sessions:", sessions.map(s => s.sessionId));

async function createSession(taskDetails, apiKey) {
  const response = await fetch("https://connect.webrun.ai/start/start-session", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${apiKey}`
    },
    body: JSON.stringify({ taskDetails })
  });

  return await response.json();
}
```

**What Happens if Limit Reached:**
```json
{
  "success": false,
  "error": "Maximum concurrent sessions reached (limit: 5)",
  "code": "SESSION_LIMIT_REACHED",
  "details": {
    "current": 5,
    "limit": 5
  }
}
```

**Solutions:**
- Terminate unused sessions before creating new ones
- Queue tasks and process sequentially
- Upgrade to a higher tier plan

**Related:**
- [Session Management](/concepts/sessions)
- [Error: SESSION_LIMIT_REACHED](/troubleshooting/errors-reference#session_limit_reached)

---

### How do I handle authentication for websites?

There are several approaches depending on the website:

**1. Provide Credentials in Task**
```javascript
const session = await fetch("https://connect.webrun.ai/start/start-session", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "Authorization": `Bearer ${apiKey}`
  },
  body: JSON.stringify({
    taskDetails: `Navigate to example.com, click login, enter username "user@example.com" and password "myPassword123", then go to dashboard`,
    startingUrl: "https://example.com/login"
  })
});
```

**2. Use Cookies/Session Storage**
```javascript
// First session: Login and get cookies
const loginSession = await createSession("Login with credentials...", apiKey);
const cookies = await getCookies(loginSession.sessionId, apiKey);

// Second session: Reuse cookies (if supported)
// Note: Cookie persistence across sessions is limited
```

**3. Handle Login via Guardrails**
```javascript
ws.onmessage = async (event) => {
  const data = JSON.parse(event.data);

  if (data.type === "guardrail_trigger") {
    if (data.data.value.includes("login") || data.data.value.includes("credentials")) {
      // Provide credentials when asked
      await fetch("https://connect.webrun.ai/start/send-message", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          sessionId,
          message: {
            actionType: "guardrail",
            taskDetails: "Username: user@example.com, Password: myPassword123",
            newState: "resume"
          }
        })
      });
    }
  }
};
```

**4. OAuth/Social Login**
- Provide redirect URLs in task details
- Handle popup windows via guardrails
- May require manual takeover for 2FA

**Related:**
- [Guardrails](/usage-guides/guardrails)
- [Security Best Practices](/essentials/security)

---

## Integration Questions

### Can I use my own API keys for LLMs?

**Short Answer:** No, not currently.

WebRun uses its own LLM infrastructure to power the browser agent. You cannot bring your own API keys or use different models.

**What You Get:**
- Optimized prompting for browser automation
- No need to manage separate API keys
- Usage tracked and billed through WebRun

**Pricing:**
- Costs are included in your WebRun usage
- Charged based on input/output tokens
- See current pricing at [webrun.ai/pricing](https://webrun.ai/pricing)

**Related:**
- [Pricing](/pricing)
- [Token Usage](/concepts/tokens)

---

### Does WebRun work with [framework]?

WebRun provides a **REST API**, **WebSocket interface**, **MCP** and OPENAI format, making it compatible with any framework or language that can make HTTP requests.

**Officially Supported:**
- JavaScript/TypeScript (Node.js, Deno, Bun)
- Python
- Any language with HTTP/WebSocket support

**Popular Integrations:**

**Next.js / React:**
```javascript
// app/api/webrun/route.js
export async function POST(request) {
  const { taskDetails } = await request.json();

  const response = await fetch("https://connect.webrun.ai/start/start-session", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${process.env.WebRun_API_KEY}`
    },
    body: JSON.stringify({ taskDetails })
  });

  return Response.json(await response.json());
}
```

**Express.js:**
```javascript
app.post('/automate', async (req, res) => {
  const { taskDetails } = req.body;

  const response = await fetch("https://connect.webrun.ai/start/start-session", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${process.env.WebRun_API_KEY}`
    },
    body: JSON.stringify({ taskDetails })
  });

  res.json(await response.json());
});
```

**Python (FastAPI):**
```python
import httpx
from fastapi import FastAPI

app = FastAPI()

@app.post("/automate")
async def automate(task_details: str):
    async with httpx.AsyncClient() as client:
        response = await client.post(
            "https://connect.webrun.ai/start/start-session",
            json={"taskDetails": task_details},
            headers={
                "Authorization": f"Bearer {os.getenv('WebRun_API_KEY')}"
            }
        )
        return response.json()
```

**Related:**
- [Quickstart](/quickstart)
- [API Reference](/api-reference/introduction)
- [Integration Examples](/integrations/examples)

---

### Can I use WebRun with the MCP protocol?

**Yes!** WebRun provides a native **Model Context Protocol (MCP) server**.

**What is MCP?**
- Protocol for connecting AI models to external tools
- Developed by Anthropic
- Allows Claude Desktop and other MCP clients to use WebRun

**Setup:**
```json
// claude_desktop_config.json
{
  "mcpServers": {
    "webrun": {
      "command": "npx",
      "args": ["-y", "@webrun/mcp-server"],
      "env": {
        "WebRun_API_KEY": "your-api-key-here"
      }
    }
  }
}
```

**Available Tools:**
- `webrun_browser_start` - Start a new session
- `webrun_browser_run_task` - Execute a task
- `webrun_browser_control` - Control session state
- `webrun_browser_get_result` - Get task results

**Resources:**
- Session streaming access
- Task result access

**Related:**
- [MCP Integration Guide](/integrations/mcp)
- [MCP Protocol Docs](https://modelcontextprotocol.io)

---

## Pricing Questions

### Is there a free tier?

**Yes!** WebRun offers a free tier for testing and small-scale usage.

**Free Tier Includes:**
- **$5 free credits** per month
- **2 concurrent sessions**
- **15 minutes session duration**
- All API features enabled
- Community support

**What You Can Do:**
- Test integration
- Build proof-of-concepts
- Automate low-volume tasks
- Approximately 200-500 simple tasks/month

**Limitations:**
- Credits reset monthly (don't roll over)
- Rate limits apply (10 req/min per endpoint)
- No SLA guarantee
- Email support only

**Upgrade When:**
- You need longer sessions (> 60 seconds)
- More concurrent sessions (> 2)
- Higher rate limits
- Priority support
- Production SLA

**Related:**
- [Pricing Plans](/pricing)
- [Sign Up](https://webrun.ai/signup)

---

### How are tokens counted?

Tokens are counted based on the content processed by the AI agent:

**Input Tokens (Context):**
- Page HTML/DOM content
- Task instructions
- Previous conversation history
- Guardrail responses
- Images and screenshots (converted to tokens)

**Output Tokens (Response):**
- Agent's reasoning and actions
- Extracted data
- Error messages
- Status updates

**Example:**
```json
{
  "usage": {
    "inputTokens": 15000,   // ~10-15 pages worth of content
    "outputTokens": 3000,   // Agent's actions and responses
    "cost": 0.018           // Total cost in USD
  }
}
```

**Token Costs (Approximate):**
- Input: ~$0.003 per 1K tokens
- Output: ~$0.015 per 1K tokens
- Prices vary by model tier

**How to Reduce Tokens:**
1. **Set Token Limits:**
   ```javascript
   {
     maxInputTokens: 10000,  // Limit context
     maxOutputTokens: 2000   // Limit response
   }
   ```

2. **Use Starting URL:**
   ```javascript
   {
     startingUrl: "https://example.com/target-page"  // Skip navigation
   }
   ```

3. **Block Unnecessary Domains:**
   ```javascript
   {
     avoidDomains: ["ads.example.com", "analytics.example.com"]
   }
   ```

4. **Simplify Tasks:**
   - Be specific and direct
   - Avoid exploration-heavy tasks

**Related:**
- [Token Usage Guide](/concepts/tokens)
- [Cost Optimization](/usage-guides/cost-optimization)
- [Pricing](/pricing)

---

### Do idle sessions cost money?

**No** - Idle sessions do not consume tokens, but they still occupy a session slot.

**How Costs Work:**
- **Costs are only incurred when tasks are running** and the AI agent processes content
- Idle time (between tasks) has no token cost
- However, idle sessions count toward your concurrent session limit

**Example:**
```javascript
// Session created - no cost yet
const session = await createSession("Navigate to example.com", apiKey);

// Task runs - COSTS TOKENS
const result1 = await runTask(session.sessionId, "Click first link", apiKey);

// Waiting 30 seconds - NO COST (but session still active)
await new Promise(r => setTimeout(r, 30000));

// Another task runs - COSTS TOKENS
const result2 = await runTask(session.sessionId, "Get page title", apiKey);

// Session terminated - no further costs
await terminateSession(session.sessionId, apiKey);
```

**Best Practices:**
- **Terminate sessions immediately when done** to free up session slots
- Don't keep sessions running "just in case"
- Use `maxDuration` to auto-terminate sessions

**Session Management:**
```javascript
try {
  const session = await createSession(taskDetails, apiKey);
  const result = await runTask(session.sessionId, task, apiKey);
  return result;
} finally {
  // Always terminate, even on error
  await terminateSession(session.sessionId, apiKey);
}
```

**Related:**
- [Session Lifecycle](/concepts/sessions#lifecycle)
- [Cost Optimization](/usage-guides/cost-optimization)

---

### Can I set spending limits?

**Yes** - You can set spending limits in your account settings.

**How to Set Limits:**
1. Go to [app.webrun.ai/billing](https://app.webrun.ai/billing)
2. Navigate to "Spending Limits"
3. Set daily, weekly, or monthly caps
4. Enable alerts at threshold percentages

**Limit Options:**
- **Hard Limit:** API requests fail when reached
- **Soft Limit:** Receive alerts but requests continue
- **Alert Thresholds:** 50%, 75%, 90%, 100%

**Example:**
```javascript
// When spending limit reached
{
  "success": false,
  "error": "Spending limit reached ($100.00). Increase limit or wait for reset.",
  "code": "SPENDING_LIMIT_REACHED"
}
```

**Monitoring:**
```javascript
// Check current usage via API
const usage = await fetch("https://connect.webrun.ai/account/usage", {
  headers: { "Authorization": `Bearer ${apiKey}` }
});

const data = await usage.json();
console.log("Current spend:", data.currentPeriodSpend);
console.log("Limit:", data.spendingLimit);
console.log("Remaining:", data.remaining);
```

**Best Practices:**
- Start with conservative limits
- Monitor usage patterns
- Set up alert notifications
- Review usage regularly

**Related:**
- [Billing Dashboard](/essentials/billing)
- [Usage Monitoring](/essentials/dashboard)

---

## Technical Questions

### How do I handle CAPTCHAs?

CAPTCHAs require human intervention. WebRun provides several approaches:

**1. Manual Takeover Mode**
```javascript
// When CAPTCHA detected, switch to manual mode
await fetch("https://connect.webrun.ai/start/send-message", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "Authorization": `Bearer ${apiKey}`
  },
  body: JSON.stringify({
    sessionId,
    message: { actionType: "state", newState: "manual" }
  })
});

// User solves CAPTCHA via video stream
// Watch stream at: https://connect.webrun.ai/stream/${sessionId}

// After CAPTCHA solved, resume agent
await fetch("https://connect.webrun.ai/start/send-message", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "Authorization": `Bearer ${apiKey}`
  },
  body: JSON.stringify({
    sessionId,
    message: { actionType: "state", newState: "resume" }
  })
});
```

**2. Guardrail Handling**
```javascript
ws.onmessage = async (event) => {
  const data = JSON.parse(event.data);

  if (data.type === "guardrail_trigger") {
    // Check if CAPTCHA mentioned
    if (data.data.value.toLowerCase().includes("captcha")) {
      // Notify user
      console.log("CAPTCHA detected - manual intervention needed");

      // Provide stream URL
      console.log(`Solve at: https://connect.webrun.ai/stream/${sessionId}`);

      // Wait for user confirmation
      const solved = await askUser("Have you solved the CAPTCHA?");

      // Resume
      await sendMessage(sessionId, {
        actionType: "guardrail",
        taskDetails: "CAPTCHA solved, continue",
        newState: "resume"
      });
    }
  }
};
```

**3. Avoid CAPTCHA-Heavy Sites**
```javascript
// Some sites are known for heavy CAPTCHA usage
const session = await fetch("https://connect.webrun.ai/start/start-session", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "Authorization": `Bearer ${apiKey}`
  },
  body: JSON.stringify({
    taskDetails: "Research topic",
    avoidDomains: [
      "heavily-protected-site.com"
    ]
  })
});
```

**Prevention:**
- Rate limit your requests
- Don't hammer the same site repeatedly
- Use residential proxies (Enterprise feature)
- Rotate sessions

**Related:**
- [Manual Control](/control)
- [CAPTCHA Handling Guide](/troubleshooting/common-issues#captcha-blocking-tasks)

---

### Can WebRun access sites behind login?

**Yes**, but with some considerations:

**Approach 1: Provide Credentials Directly**
```javascript
const session = await fetch("https://connect.webrun.ai/start/start-session", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "Authorization": `Bearer ${apiKey}`
  },
  body: JSON.stringify({
    taskDetails: `
      1. Navigate to example.com/login
      2. Enter username: user@example.com
      3. Enter password: myPassword123
      4. Click submit
      5. Once logged in, go to /dashboard and extract data
    `,
    startingUrl: "https://example.com/login"
  })
});
```

**Approach 2: Handle via Guardrails**
```javascript
// Agent will ask for credentials when needed
ws.onmessage = async (event) => {
  const data = JSON.parse(event.data);

  if (data.type === "guardrail_trigger") {
    if (data.data.value.includes("login") || data.data.value.includes("username")) {
      await sendMessage(sessionId, {
        actionType: "guardrail",
        taskDetails: "Username: user@example.com, Password: myPassword123",
        newState: "resume"
      });
    }
  }
};
```

**Limitations:**
- **2FA/MFA:** Requires manual intervention or external automation
- **OAuth:** Complex flows may need manual takeover
- **Session Persistence:** Cookies don't persist across different sessions
- **CAPTCHA:** May be triggered on login

**Security Best Practices:**
- Don't hardcode credentials
- Use environment variables
- Consider using test/sandbox accounts
- Rotate credentials regularly

**Alternatives:**
- Use public pages when possible
- Check if site has an API
- Consider scraping logged-out content

**Related:**
- [Authentication Guide](/usage-guides/authentication)
- [Guardrails](/usage-guides/guardrails)

---

### What's the resolution of the browser?

**Default Resolution:**
- **Width:** 1920 pixels
- **Height:** 1080 pixels
- **Viewport:** Full HD (1080p)

**Device Emulation:**
Currently, WebRun does not support:
- Custom viewport sizes
- Mobile device emulation
- Different screen resolutions
- Responsive mode testing

**What This Means:**
- All sessions use desktop resolution
- Mobile sites will show desktop version (unless responsive)
- Testing mobile layouts requires the desktop-responsive version

**Workarounds for Mobile:**
```javascript
// Some sites switch to mobile based on user agent
// This is not currently supported in WebRun
```

**Future Features:**
- Mobile device emulation (coming soon)
- Custom viewport dimensions
- Device profiles (iPhone, iPad, etc.)

**Related:**
- [Browser Specifications](/concepts/browser-specs)
- [Feature Roadmap](/essentials/roadmap)

---

### Can I use proxies?

**Standard Plans:** No proxy support

**Enterprise Plans:** Yes, custom proxy configuration available

**Enterprise Features:**
- Residential proxy pools
- Geographic targeting (US, EU, Asia, etc.)
- Rotating IPs
- Custom proxy servers

**Why Use Proxies:**
- Access geo-restricted content
- Avoid IP-based rate limits
- Appear as different users
- Reduce CAPTCHA frequency

**Contact:** Email sales@webrun.ai for Enterprise pricing

**Alternatives for Standard Plans:**
- Use rate limiting to avoid blocks
- Rotate between multiple API keys
- Space out requests over time

**Related:**
- [Enterprise Features](/pricing#enterprise)
- [Contact Sales](mailto:sales@webrun.ai)

---

### Can I access the browser's console logs?

**Not directly**, but you can access page errors and warnings through the task result.

**What You Get:**
```javascript
const result = await pollForResult(sessionId, taskId, apiKey);

console.log("Task result:", result.data.result);
// May include error messages encountered

// Errors are also surfaced in events
ws.onmessage = (event) => {
  const data = JSON.parse(event.data);

  if (data.type === "error") {
    console.error("Browser error:", data.data);
  }
};
```

**Console Access Limitations:**
- No real-time console.log() output
- Critical errors are captured
- JavaScript errors may be included in result

**Debugging Tips:**
1. **Use guardrails to get information:**
   ```javascript
   taskDetails: "Navigate to page and tell me if there are any JavaScript errors visible"
   ```

2. **Check page content:**
   ```javascript
   taskDetails: "Get the error message displayed on the page"
   ```

3. **Enable verbose logging in your code:**
   ```javascript
   const result = await pollForResult(sessionId, taskId, apiKey);
   console.log("Full result:", JSON.stringify(result, null, 2));
   ```

**Related:**
- [Debugging Guide](/usage-guides/debugging)
- [Events Reference](/events)

---

### What User-Agent does WebRun use?

WebRun uses a **standard Chrome User-Agent** that matches the Chrome version.

**Example:**
```
Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36
```

**Characteristics:**
- Appears as Windows 10, 64-bit Chrome browser
- Latest stable Chrome version
- Standard desktop user agent
- Not marked as headless or automated

**Cannot Currently Customize:**
- User agent string
- Platform (always Windows)
- Browser version
- Device type

**Detection:**
- Some sophisticated bot detection may still identify automation
- WebRun works on most sites
- CAPTCHAs may still appear on high-security sites

**Related:**
- [Browser Specifications](/concepts/browser-specs)

---

## Support & Resources

### Where can I find code examples?

**Official Resources:**
- [Quickstart Guide](/quickstart) - Basic integration
- [API Reference](/api-reference/introduction) - All endpoints with examples
- [Usage Guides](/usage-guides/overview) - Common patterns
- [Integration Examples](/integrations/examples) - Framework-specific code

**GitHub:**
- [webrun-examples](https://github.com/webrun-ai/examples) - Sample projects
- [webrun-sdk](https://github.com/webrun-ai/sdk) - Official SDKs

**Example: Complete Task Flow**
```javascript
const WebRun_API_KEY = process.env.WebRun_API_KEY;

async function automateTask(taskDetails) {
  let sessionId;

  try {
    // 1. Create session
    const sessionResponse = await fetch(
      "https://connect.webrun.ai/start/start-session",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${WebRun_API_KEY}`
        },
        body: JSON.stringify({
          taskDetails,
          maxDuration: 120000
        })
      }
    );

    const session = await sessionResponse.json();
    sessionId = session.sessionId;

    // 2. Monitor via WebSocket
    const ws = new WebSocket(
      `wss://connect.webrun.ai/ws?sessionId=${sessionId}&apiKey=${WebRun_API_KEY}`
    );

    return new Promise((resolve, reject) => {
      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);

        if (data.type === "task_completed") {
          ws.close();
          resolve(data.data);
        }

        if (data.type === "error") {
          ws.close();
          reject(new Error(data.data.message));
        }
      };
    });

  } catch (error) {
    console.error("Error:", error);
    throw error;
  } finally {
    // 3. Clean up
    if (sessionId) {
      await fetch("https://connect.webrun.ai/start/send-message", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${WebRun_API_KEY}`
        },
        body: JSON.stringify({
          sessionId,
          message: { actionType: "state", newState: "terminate" }
        })
      });
    }
  }
}

// Usage
const result = await automateTask("Navigate to example.com and get the page title");
console.log("Result:", result);
```

---

### How do I get support?

**Support Channels by Plan:**

**Free Tier:**
- Documentation (you're reading it!)
- Community Discord
- Email support (48-hour response)

**Pro Tier:**
- Priority email support (24-hour response)
- Live chat during business hours
- Video call support (by appointment)

**Enterprise:**
- Dedicated account manager
- 24/7 phone support
- SLA guarantees
- Custom integrations support

**Contact Information:**
- **Email:** support@webrun.ai
- **Discord:** [discord.gg/webrun](https://discord.gg/webrun)
- **Status:** [status.webrun.ai](https://status.webrun.ai)

**Before Contacting Support:**
1. Check this documentation
2. Review [Common Issues](/troubleshooting/common-issues)
3. Check [Error Reference](/troubleshooting/errors-reference)
4. Look at system status page

**What to Include:**
- Session ID and task ID
- Full error message/response
- Code snippet (redact API keys!)
- Timestamp of occurrence
- What you've already tried

---

## Related Resources

<CardGroup cols={2}>
  <Card title="Error Codes Reference" icon="exclamation-triangle" href="/troubleshooting/errors-reference">
    Complete error code documentation
  </Card>
  <Card title="Common Issues" icon="circle-exclamation" href="/troubleshooting/common-issues">
    Solutions for frequent problems
  </Card>
  <Card title="Quickstart Guide" icon="rocket" href="/quickstart">
    Get started in 5 minutes
  </Card>
  <Card title="API Reference" icon="code" href="/api-reference/introduction">
    Complete API documentation
  </Card>
</CardGroup>
